<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MediaTracked</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="MediaTracked">
  <meta name="description" content="Track books, audiobooks, movies, TV shows, and games privately and offline with MediaTracked.">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/icon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous">
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Include CryptoJS for encryption -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <!-- Include sql.js for SQLite in the browser -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js"></script>
</head>
<body class="min-h-screen bg-gray-200 font-sans antialiased">
  <div class="max-w-3xl mx-auto p-6">
    <header class="text-center mb-10">
      <h1 class="text-4xl font-extrabold text-gray-900 animate-fade-in">MediaTracked</h1>
      <p class="text-lg text-gray-600 mt-3 animate-fade-in-delayed">Track your books, audiobooks, movies, TV shows, and gamesâ€”privately and offline.</p>
    </header>

    <!-- Cloud Storage Settings -->
    <section id="cloud-storage-settings" class="bg-green-50 p-4 rounded-lg mb-10 text-center animate-fade-in">
      <p class="text-gray-800 mb-2">Sync your media list across devices! <button onclick="showCloudStoragePurchase()" class="text-green-500 hover:underline font-semibold">Enable Cloud Storage for $5</button></p>
      <p id="enter-cloud-code-section" class="text-gray-800 mb-2 hidden">
        Already paid? Enter your code: 
        <input id="cloud-storage-code" type="text" placeholder="e.g., CLOUD-XYZ123" class="p-1 border border-gray-300 rounded-md mx-2" />
        <button onclick="applyCloudStorageCode()" class="text-green-500 hover:underline font-semibold">Apply</button>
      </p>
      <p id="cloud-storage-message" class="text-gray-800 mb-2 hidden"></p>
      <p id="cloud-sync-section" class="text-gray-800 mb-2 hidden">
        <label class="flex items-center justify-center gap-2">
          <input id="cloud-sync-enabled" type="checkbox" onchange="toggleCloudSync()" />
          Enable Cloud Sync
        </label>
        <input id="github-pat" type="password" placeholder="GitHub Personal Access Token" class="p-1 border border-gray-300 rounded-md mx-2 mt-2 hidden" />
        <button id="save-pat-button" onclick="saveGitHubPAT()" class="text-green-500 hover:underline font-semibold mt-2 hidden">Save PAT</button>
        <p id="sync-status" class="text-sm text-gray-600 mt-2"></p>
      </p>
    </section>

    <!-- Add Media Form -->
    <section class="bg-white p-6 rounded-lg shadow-md mb-10 transition-transform duration-300 hover:scale-[1.02]">
      <h2 class="text-2xl font-semibold text-gray-900 mb-4">Add New Media</h2>
      <div class="flex flex-col gap-4">
        <div class="relative">
          <input
            id="title"
            type="text"
            placeholder="Enter title (e.g., a book or movie)"
            aria-label="Media title"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition-colors duration-200"
            oninput="fetchAutocomplete()"
          />
          <div id="autocomplete-loading" class="absolute right-3 top-3 hidden">
            <i class="fas fa-spinner fa-spin text-gray-400"></i>
          </div>
          <ul id="autocomplete-list" class="absolute z-20 w-full bg-white border border-gray-300 rounded-lg mt-1 max-h-48 overflow-y-auto hidden shadow-lg" role="listbox"></ul>
        </div>
        <select id="type" onchange="updateStatusOptions()" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" aria-label="Media type">
          <option value="Book">Book</option>
          <option value="Audiobook">Audiobook</option>
          <option value="TV Show">TV Show</option>
          <option value="Movie">Movie</option>
          <option value="Game">Game</option>
        </select>
        <select id="status" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" aria-label="Media status">
          <option value="To Read">To Read</option>
          <option value="Reading">Reading</option>
          <option value="Read">Read</option>
        </select>
        <button
          onclick="addMedia()"
          class="bg-blue-500 text-white p-3 rounded-lg hover:bg-blue-600 transition-colors duration-200 text-lg"
        >
          Add Media
        </button>
      </div>
    </section>

    <!-- Filter Options -->
    <section class="mb-10">
      <h2 class="text-2xl font-semibold text-gray-900 mb-4">Filter</h2>
      <select
        id="filter"
        onchange="renderMedia()"
        class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
        aria-label="Filter media"
      >
        <option value="All">All</option>
        <option value="Books">Books</option>
        <option value="Audiobooks">Audiobooks</option>
        <option value="TV Shows">TV Shows</option>
        <option value="Movies">Movies</option>
        <option value="Games">Games</option>
        <option value="To Read">To Read</option>
        <option value="Reading">Reading</option>
        <option value="Read">Read</option>
        <option value="To Listen">To Listen</option>
        <option value="Listening">Listening</option>
        <option value="Listened">Listened</option>
        <option value="To Watch">To Watch</option>
        <option value="Watching">Watching</option>
        <option value="Watched">Watched</option>
        <option value="To Play">To Play</option>
        <option value="Playing">Playing</option>
        <option value="Played">Played</option>
      </select>
    </section>

    <!-- Media List -->
    <section class="bg-white p-6 rounded-lg shadow-md mb-10 transition-transform duration-300 hover:scale-[1.02]">
      <h2 class="text-2xl font-semibold text-gray-900 mb-4">Your Media</h2>
      <div id="media-list" class="space-y-6"></div>
    </section>

    <!-- Suggestions Section -->
    <section id="suggestions" class="bg-white p-6 rounded-lg shadow-md mb-10 transition-transform duration-300 hover:scale-[1.02]">
      <h2 class="text-2xl font-semibold text-gray-900 mb-4">Suggestions for You</h2>
      <div id="suggestions-list" class="space-y-4"></div>
    </section>

    <!-- Affiliate Links -->
    <section id="affiliate-links" class="bg-white p-6 rounded-lg shadow-md mb-10 transition-transform duration-300 hover:scale-[1.02]">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-2xl font-semibold text-gray-900">Explore More</h2>
        <button onclick="toggleAffiliateLinks()" class="text-blue-500 hover:text-blue-600 text-sm" aria-label="Toggle affiliate links">
          <i id="affiliate-toggle-icon" class="fas fa-chevron-up"></i>
        </button>
      </div>
      <div id="affiliate-content" class="space-y-2">
        <p class="text-gray-600 text-sm">Discover your next favorite media (affiliate links):</p>
        <div id="affiliate-list" class="flex flex-col gap-2"></div>
      </div>
    </section>
  </div>

  <script>
    let media = JSON.parse(localStorage.getItem('mediatracked_media')) || [];
    let cloudStorageCode = localStorage.getItem('mediatracked_cloudStorageCode') || null;
    let isCloudStorageEnabled = false; // Will be set after loading from cloud
    let isCloudSyncEnabled = localStorage.getItem('mediatracked_cloudSyncEnabled') === 'true';
    let githubPAT = localStorage.getItem('mediatracked_githubPAT') || '';
    let userId = localStorage.getItem('mediatracked_userId') || generateUserId();
    let isAffiliateCollapsed = false;
    let db; // SQLite database instance

    const statusOptions = {
      Book: ['To Read', 'Reading', 'Read'],
      Audiobook: ['To Listen', 'Listening', 'Listened'],
      'TV Show': ['To Watch', 'Watching', 'Watched'],
      Movie: ['To Watch', 'Watching', 'Watched'],
      Game: ['To Play', 'Playing', 'Played']
    };

    // Affiliate Links for "Explore More" section (placeholders)
    const affiliateLinks = {
      Book: [
        { text: 'Dune by Frank Herbert', url: 'https://bookshop.org/a/YOUR_BOOKSHOP_ID/9780441172719' },
        { text: 'Explore Books on Amazon', url: 'https://www.amazon.com/s?k=books&tag=YOUR_AMAZON_TAG' }
      ],
      Audiobook: [
        { text: 'Dune Audiobook', url: 'https://www.audible.com/pd/Dune-Audiobook/B002V1OF70?ref=YOUR_AFFILIATE_TAG' },
        { text: 'Browse Audible Audiobooks', url: 'https://www.amazon.com/Audible-Books-and-Originals/b?node=18145289011&tag=YOUR_AMAZON_TAG' }
      ],
      'TV Show': [
        { text: 'Watch Game of Thrones', url: 'https://www.amazon.com/Game-of-Thrones-Season-1/dp/B007HJ84ZK?tag=YOUR_AMAZON_TAG' },
        { text: 'Explore TV Shows on Amazon', url: 'https://www.amazon.com/s?k=tv+shows&tag=YOUR_AMAZON_TAG' }
      ],
      Movie: [
        { text: 'Dune (2021) Movie', url: 'https://www.amazon.com/Dune-Timothee-Chalamet/dp/B09M7XJH2B?tag=YOUR_AMAZON_TAG' },
        { text: 'Browse Movies on Amazon', url: 'https://www.amazon.com/s?k=movies&tag=YOUR_AMAZON_TAG' }
      ],
      Game: [
        { text: 'Cyberpunk 2077', url: 'https://www.humblebundle.com/store/cyberpunk-2077?partner=YOUR_HUMBLE_ID' },
        { text: 'Explore Games on Amazon', url: 'https://www.amazon.com/s?k=video+games&tag=YOUR_AMAZON_TAG' }
      ]
    };

    const AMAZON_AFFILIATE_TAG = 'YOUR_AMAZON_TAG'; // Replace with your Amazon Associates tag (e.g., 'yourtag-20')
    const AMAZON_ACCESS_KEY = 'YOUR_ACCESS_KEY'; // Replace with your PA-API Access Key
    const AMAZON_SECRET_KEY = 'YOUR_SECRET_KEY'; // Replace with your PA-API Secret Key
    const ENCRYPTION_KEY = 'your-secure-encryption-key'; // Replace with a secure key in production

    // Cache for suggestions to avoid repeated queries
    let suggestionsCache = JSON.parse(localStorage.getItem('mediatracked_suggestions')) || {};

    function generateUserId() {
      const id = 'user_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('mediatracked_userId', id);
      return id;
    }

    function sanitizeInput(input) {
      const div = document.createElement('div');
      div.textContent = input;
      return div.innerHTML;
    }

    async function initSQLite() {
      const SQL = await initSqlJs({
        locateFile: () => 'https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.wasm'
      });
      return SQL;
    }

    function calculateMediaTypes() {
      const types = {};
      media.forEach(item => {
        types[item.type] = (types[item.type] || 0) + 1;
      });
      return JSON.stringify(types);
    }

    function saveMedia() {
      localStorage.setItem('mediatracked_media', JSON.stringify(media));
      if (isCloudSyncEnabled && githubPAT) {
        syncToCloud();
      }
    }

    function saveSuggestions() {
      localStorage.setItem('mediatracked_suggestions', JSON.stringify(suggestionsCache));
      if (isCloudSyncEnabled && githubPAT) {
        syncToCloud();
      }
    }

    function generateCloudStorageCode() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      let code = 'CLOUD-';
      for (let i = 0; i < 6; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return code;
    }

    function showCloudStoragePurchase() {
      const code = generateCloudStorageCode();
      cloudStorageCode = code;
      localStorage.setItem('mediatracked_cloudStorageCode', code);
      isCloudStorageEnabled = true;
      updateCloudStorageVisibility();
      const message = document.getElementById('cloud-storage-message');
      message.classList.remove('hidden');
      message.innerHTML = `Cloud storage enabled! Your code is: <strong>${code}</strong>. Save this code to use on other devices. Now enter your GitHub Personal Access Token to enable sync.`;
      alert('Cloud storage enabled! (Simulated $5 purchase. Add Stripe: https://stripe.com/docs/payments)');
      syncToCloud(); // Sync the payment status to the database
    }

    function applyCloudStorageCode() {
      const inputCode = document.getElementById('cloud-storage-code').value.trim();
      const message = document.getElementById('cloud-storage-message');
      if (inputCode === cloudStorageCode) {
        isCloudStorageEnabled = true;
        localStorage.setItem('mediatracked_cloudStorageCode', inputCode);
        updateCloudStorageVisibility();
        message.classList.remove('hidden');
        message.innerHTML = 'Code applied! Cloud storage enabled. Now enter your GitHub Personal Access Token to enable sync.';
        syncToCloud(); // Sync the payment status to the database
      } else {
        message.classList.remove('hidden');
        message.innerHTML = 'Invalid code. Please try again or purchase cloud storage.';
      }
    }

    function updateStatusOptions() {
      const type = document.getElementById('type').value;
      const statusSelect = document.getElementById('status');
      statusSelect.innerHTML = statusOptions[type].map(status => `<option value="${status}">${status}</option>`).join('');
    }

    // Simplified Amazon PA-API request (signature generation needs a backend proxy in production)
    async function fetchAmazonData(keywords, searchIndex, operation = 'SearchItems') {
      const timestamp = new Date().toISOString().replace(/[:\-]|\.\d{3}/g, '');
      const params = {
        Service: 'AWSECommerceService',
        Operation: operation,
        AWSAccessKeyId: AMAZON_ACCESS_KEY,
        AssociateTag: AMAZON_AFFILIATE_TAG,
        SearchIndex: searchIndex,
        Keywords: keywords,
        ItemCount: 5,
        ResponseGroup: 'ItemAttributes,Offers',
        Timestamp: timestamp
      };

      // In production, you need to generate a signature using AMAZON_SECRET_KEY (HMAC-SHA256)
      // For now, we'll mock the request URL (use a backend proxy to sign requests)
      const queryString = Object.keys(params)
        .sort()
        .map(key => `${key}=${encodeURIComponent(params[key])}`)
        .join('&');
      const url = `https://webservices.amazon.com/paapi5/${operation.toLowerCase()}?${queryString}&Signature=TO_BE_GENERATED`;

      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network error');
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Amazon PA-API error:', error);
        return null;
      }
    }

    async function fetchAutocomplete() {
      const titleInput = sanitizeInput(document.getElementById('title').value.trim());
      const type = document.getElementById('type').value;
      const autocompleteList = document.getElementById('autocomplete-list');
      const loadingIndicator = document.getElementById('autocomplete-loading');

      if (titleInput.length < 3) {
        autocompleteList.innerHTML = '';
        autocompleteList.classList.add('hidden');
        loadingIndicator.classList.add('hidden');
        return;
      }

      loadingIndicator.classList.remove('hidden');
      autocompleteList.classList.add('hidden');

      const searchIndex = {
        Book: 'Books',
        Audiobook: 'Books', // Filter for audiobooks later
        Movie: 'Movies',
        'TV Show': 'Movies', // Amazon groups TV shows under Movies
        Game: 'VideoGames'
      }[type];

      const data = await fetchAmazonData(titleInput, searchIndex);
      let results = [];

      if (data && data.ItemsResult && data.ItemsResult.Items) {
        results = data.ItemsResult.Items.map(item => {
          const isAudiobook = type === 'Audiobook' && item.ItemInfo.Classifications.ProductGroup.DisplayValue.toLowerCase().includes('audiobook');
          if (type === 'Audiobook' && !isAudiobook) return null;
          return {
            title: item.ItemInfo.Title.DisplayValue,
            year: item.ItemInfo.ContentInfo?.PublicationDate?.DisplayValue?.split('-')[0] || ''
          };
        }).filter(item => item);
      } else {
        results = [{ title: navigator.onLine ? 'Error fetching data' : 'Offline? Enter manually', year: '' }];
      }

      loadingIndicator.classList.add('hidden');
      autocompleteList.innerHTML = results.length && results[0].title !== 'Error fetching data' && results[0].title !== 'Offline? Enter manually'
        ? results.map((item, index) => `
            <li
              class="p-3 hover:bg-gray-100 cursor-pointer text-gray-800"
              role="option"
              aria-selected="false"
              onclick="selectAutocomplete('${sanitizeInput(item.title).replace(/'/g, "\\'")}')"
              onkeydown="if(event.key === 'Enter') selectAutocomplete('${sanitizeInput(item.title).replace(/'/g, "\\'")}')"
              tabindex="0"
            >
              ${sanitizeInput(item.title)} (${item.year || 'N/A'})
            </li>
          `).join('')
        : `<li class="p-3 text-gray-500">${results[0]?.title || 'No results found. Enter manually.'}</li>`;
      autocompleteList.classList.remove('hidden');
    }

    function selectAutocomplete(title) {
      document.getElementById('title').value = title;
      document.getElementById('autocomplete-list').classList.add('hidden');
    }

    function addMedia(title, type, status) {
      if (!title) {
        title = sanitizeInput(document.getElementById('title').value.trim());
        type = document.getElementById('type').value;
        status = document.getElementById('status').value;
      }

      if (!title) {
        alert('Please enter a title.');
        return;
      }

      const newMedia = { id: Date.now(), title, type, status };
      media.push(newMedia);
      saveMedia();
      document.getElementById('title').value = '';
      document.getElementById('autocomplete-list').classList.add('hidden');
      renderMedia();
      fetchSuggestions();
    }

    function toggleStatus(id) {
      media = media.map(item => {
        if (item.id !== id) return item;
        const statuses = statusOptions[item.type];
        const currentIndex = statuses.indexOf(item.status);
        const nextIndex = (currentIndex + 1) % statuses.length;
        return { ...item, status: statuses[nextIndex] };
      });
      saveMedia();
      renderMedia();
    }

    function deleteMedia(id) {
      media = media.filter(item => item.id !== id);
      saveMedia();
      renderMedia();
      fetchSuggestions();
    }

    function updateCloudStorageVisibility() {
      const enterCloudCodeSection = document.getElementById('enter-cloud-code-section');
      const cloudSyncSection = document.getElementById('cloud-sync-section');
      const githubPATInput = document.getElementById('github-pat');
      const savePATButton = document.getElementById('save-pat-button');

      if (isCloudStorageEnabled) {
        enterCloudCodeSection.classList.add('hidden');
        cloudSyncSection.classList.remove('hidden');
        if (!githubPAT) {
          githubPATInput.classList.remove('hidden');
          savePATButton.classList.remove('hidden');
        }
        document.getElementById('cloud-sync-enabled').checked = isCloudSyncEnabled;
      } else {
        enterCloudCodeSection.classList.remove('hidden');
        cloudSyncSection.classList.add('hidden');
        githubPATInput.classList.add('hidden');
        savePATButton.classList.add('hidden');
      }
    }

    function toggleCloudSync() {
      isCloudSyncEnabled = document.getElementById('cloud-sync-enabled').checked;
      localStorage.setItem('mediatracked_cloudSyncEnabled', isCloudSyncEnabled);
      if (isCloudSyncEnabled) {
        syncToCloud();
      }
    }

    function saveGitHubPAT() {
      githubPAT = document.getElementById('github-pat').value.trim();
      if (!githubPAT) {
        alert('Please enter a valid GitHub Personal Access Token.');
        return;
      }
      localStorage.setItem('mediatracked_githubPAT', githubPAT);
      document.getElementById('github-pat').classList.add('hidden');
      document.getElementById('save-pat-button').classList.add('hidden');
      syncToCloud(); // Sync the PAT to the database
    }

    async function syncToCloud() {
      if (!isCloudSyncEnabled || !githubPAT) {
        const syncStatus = document.getElementById('sync-status');
        syncStatus.textContent = 'Sync disabled or no PAT provided.';
        return;
      }

      const syncStatus = document.getElementById('sync-status');
      syncStatus.textContent = 'Checking payment status...';

      try {
        const SQL = await initSQLite();

        // Load the database
        if (!db) {
          const response = await fetch(`https://api.github.com/repos/yourusername/mediatracked-user-data/contents/mediatracked.db`, {
            headers: {
              'Authorization': `token ${githubPAT}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          });

          if (response.ok) {
            const fileData = await response.json();
            const binaryString = atob(fileData.content);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            db = new SQL.Database(bytes);
          } else {
            db = new SQL.Database();
            db.run(`
              CREATE TABLE IF NOT EXISTS user_data (
                user_id TEXT PRIMARY KEY,
                media TEXT,
                suggestions_cache TEXT,
                has_paid_cloud_storage INTEGER DEFAULT 0,
                media_types TEXT,
                github_pat TEXT
              );
            `);
          }
        }

        // Check payment status directly from the database
        const stmt = db.prepare('SELECT has_paid_cloud_storage FROM user_data WHERE user_id = ?');
        stmt.bind([userId]);
        let hasPaid = 0;
        if (stmt.step()) {
          const row = stmt.getAsObject();
          hasPaid = row.has_paid_cloud_storage || 0;
        }
        stmt.free();

        if (!hasPaid) {
          isCloudStorageEnabled = false;
          isCloudSyncEnabled = false;
          localStorage.setItem('mediatracked_cloudSyncEnabled', 'false');
          updateCloudStorageVisibility();
          syncStatus.textContent = 'Access denied: Please purchase cloud storage to sync.';
          return;
        }

        syncStatus.textContent = 'Syncing to cloud...';

        // Encrypt data before storing
        const encryptedMedia = CryptoJS.AES.encrypt(JSON.stringify(media), ENCRYPTION_KEY).toString();
        const encryptedSuggestionsCache = CryptoJS.AES.encrypt(JSON.stringify(suggestionsCache), ENCRYPTION_KEY).toString();
        const encryptedPAT = CryptoJS.AES.encrypt(githubPAT, ENCRYPTION_KEY).toString();
        const mediaTypes = calculateMediaTypes();

        // Insert or update user data
        db.run(`
          INSERT OR REPLACE INTO user_data (user_id, media, suggestions_cache, has_paid_cloud_storage, media_types, github_pat)
          VALUES (?, ?, ?, ?, ?, ?);
        `, [userId, encryptedMedia, encryptedSuggestionsCache, isCloudStorageEnabled ? 1 : 0, mediaTypes, encryptedPAT]);

        // Export the database as a binary array
        const binaryArray = db.export();
        const base64Data = btoa(String.fromCharCode(...binaryArray));

        // Check if the file exists to get its SHA
        let sha = '';
        try {
          const getFileResponse = await fetch(`https://api.github.com/repos/yourusername/mediatracked-user-data/contents/mediatracked.db`, {
            headers: {
              'Authorization': `token ${githubPAT}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          });
          if (getFileResponse.ok) {
            const fileData = await getFileResponse.json();
            sha = fileData.sha;
          }
        } catch (error) {
          // File doesn't exist, proceed to create it
        }

        // Write the updated database to GitHub
        const response = await fetch(`https://api.github.com/repos/yourusername/mediatracked-user-data/contents/mediatracked.db`, {
          method: 'PUT',
          headers: {
            'Authorization': `token ${githubPAT}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: `Update database`,
            content: base64Data,
            sha: sha || undefined
          })
        });

        if (response.ok) {
          syncStatus.textContent = 'Successfully synced to cloud!';
        } else {
          throw new Error('Failed to sync');
        }
      } catch (error) {
        console.error('Cloud sync error:', error);
        syncStatus.textContent = 'Failed to sync to cloud. Check your PAT and connection.';
      }
    }

    async function loadFromCloud() {
      if (!githubPAT) {
        const syncStatus = document.getElementById('sync-status');
        syncStatus.textContent = 'Please enter your GitHub PAT to load data.';
        return;
      }

      const syncStatus = document.getElementById('sync-status');
      syncStatus.textContent = 'Loading from cloud...';

      try {
        const SQL = await initSQLite();

        const response = await fetch(`https://api.github.com/repos/yourusername/mediatracked-user-data/contents/mediatracked.db`, {
          headers: {
            'Authorization': `token ${githubPAT}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });

        if (response.ok) {
          const fileData = await response.json();
          const binaryString = atob(fileData.content);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          db = new SQL.Database(bytes);

          // Query the user's data
          const stmt = db.prepare('SELECT media, suggestions_cache, has_paid_cloud_storage, github_pat FROM user_data WHERE user_id = ?');
          stmt.bind([userId]);
          if (stmt.step()) {
            const row = stmt.getAsObject();
            const decryptedMedia = CryptoJS.AES.decrypt(row.media, ENCRYPTION_KEY).toString(CryptoJS.enc.Utf8);
            const decryptedSuggestionsCache = CryptoJS.AES.decrypt(row.suggestions_cache, ENCRYPTION_KEY).toString(CryptoJS.enc.Utf8);
            const decryptedPAT = row.github_pat ? CryptoJS.AES.decrypt(row.github_pat, ENCRYPTION_KEY).toString(CryptoJS.enc.Utf8) : '';
            media = JSON.parse(decryptedMedia) || [];
            suggestionsCache = JSON.parse(decryptedSuggestionsCache) || {};
            isCloudStorageEnabled = row.has_paid_cloud_storage === 1;
            if (decryptedPAT && !githubPAT) {
              githubPAT = decryptedPAT;
              localStorage.setItem('mediatracked_githubPAT', githubPAT);
            }
            localStorage.setItem('mediatracked_media', JSON.stringify(media));
            localStorage.setItem('mediatracked_suggestions', JSON.stringify(suggestionsCache));
            updateCloudStorageVisibility();
            syncStatus.textContent = 'Successfully loaded from cloud!';
            renderMedia();
            fetchSuggestions();
          } else {
            syncStatus.textContent = 'No cloud data found for this user.';
          }
          stmt.free();
        } else {
          throw new Error('Failed to load');
        }
      } catch (error) {
        console.error('Cloud load error:', error);
        syncStatus.textContent = 'Failed to load from cloud. Check your PAT and connection.';
      }
    }

    function toggleAffiliateLinks() {
      isAffiliateCollapsed = !isAffiliateCollapsed;
      const content = document.getElementById('affiliate-content');
      const icon = document.getElementById('affiliate-toggle-icon');
      content.classList.toggle('hidden');
      icon.classList.toggle('fa-chevron-up');
      icon.classList.toggle('fa-chevron-down');
    }

    function generateAffiliateLink(title, type) {
      const searchTerm = encodeURIComponent(`${title} ${type.toLowerCase()}`);
      return `https://www.amazon.com/s?k=${searchTerm}&tag=${AMAZON_AFFILIATE_TAG}`;
    }

    async function fetchSuggestions() {
      const suggestionsList = document.getElementById('suggestions-list');
      suggestionsList.innerHTML = '<p class="text-gray-500 text-center py-4">Loading suggestions...</p>';

      const recentMedia = media.slice(-3);
      let suggestions = [];

      for (const item of recentMedia) {
        const cacheKey = `${item.type}-${item.title}`;
        if (suggestionsCache[cacheKey]) {
          suggestions = suggestions.concat(suggestionsCache[cacheKey]);
          continue;
        }

        let relatedItems = [];
        const searchIndex = {
          Book: 'Books',
          Audiobook: 'Books',
          Movie: 'Movies',
          'TV Show': 'Movies',
          Game: 'VideoGames'
        }[item.type];

        // First, search for the item to get its metadata (e.g., author, genre)
        const searchData = await fetchAmazonData(item.title, searchIndex);
        if (!searchData || !searchData.ItemsResult || !searchData.ItemsResult.Items) {
          continue;
        }

        const foundItem = searchData.ItemsResult.Items[0];
        if (!foundItem) continue;

        // For Books/Audiobooks: Search by author
        if (item.type === 'Book' || item.type === 'Audiobook') {
          const author = foundItem.ItemInfo.ByLineInfo?.Contributors?.find(c => c.Role === 'Author')?.Name;
          if (author) {
            const authorData = await fetchAmazonData(`inauthor:${author}`, 'Books');
            if (authorData && authorData.ItemsResult && authorData.ItemsResult.Items) {
              relatedItems = authorData.ItemsResult.Items
                .filter(d => d.ItemInfo.Title.DisplayValue !== item.title)
                .map(d => {
                  const isAudiobook = d.ItemInfo.Classifications.ProductGroup.DisplayValue.toLowerCase().includes('audiobook');
                  if (item.type === 'Audiobook' && !isAudiobook) return null;
                  if (item.type === 'Book' && isAudiobook) return null;
                  return {
                    title: d.ItemInfo.Title.DisplayValue,
                    type: item.type,
                    status: statusOptions[item.type][0],
                    source: `Based on ${item.title} by ${author}`
                  };
                })
                .filter(d => d);
            }
          }
        }
        // For Movies/TV Shows/Games: Search by genre
        else {
          const genre = foundItem.ItemInfo.Classifications?.Genre?.DisplayValue || '';
          if (genre) {
            const genreData = await fetchAmazonData(genre, searchIndex);
            if (genreData && genreData.ItemsResult && genreData.ItemsResult.Items) {
              relatedItems = genreData.ItemsResult.Items
                .filter(d => d.ItemInfo.Title.DisplayValue !== item.title)
                .map(d => ({
                  title: d.ItemInfo.Title.DisplayValue,
                  type: item.type,
                  status: statusOptions[item.type][0],
                  source: `Similar to ${item.title}`
                }));
            }
          }
        }

        if (relatedItems.length > 0) {
          suggestionsCache[cacheKey] = relatedItems;
          suggestions = suggestions.concat(relatedItems);
        }
      }

      saveSuggestions();

      // Deduplicate suggestions by title
      const seenTitles = new Set();
      suggestions = suggestions.filter(item => {
        if (seenTitles.has(item.title)) return false;
        seenTitles.add(item.title);
        return true;
      });

      // Limit to 5 suggestions
      suggestions = suggestions.slice(0, 5);

      // Render suggestions with affiliate links
      suggestionsList.innerHTML = suggestions.length === 0
        ? '<p class="text-gray-500 text-center py-4">No suggestions yet. Add more media to get recommendations!</p>'
        : suggestions.map(item => `
            <div class="flex justify-between items-center p-4 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors duration-200">
              <div>
                <h4 class="font-medium text-gray-900 text-lg">${sanitizeInput(item.title)}</h4>
                <p class="text-sm text-gray-600">${item.type} | ${item.source}</p>
              </div>
              <div class="flex gap-4">
                <button
                  onclick="addMedia('${sanitizeInput(item.title).replace(/'/g, "\\'")}', '${item.type}', '${item.status}')"
                  class="text-blue-500 hover:text-blue-600 transition-colors duration-200 text-sm font-medium"
                >
                  Add to List
                </button>
                <a
                  href="${generateAffiliateLink(item.title, item.type)}"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="text-green-500 hover:text-green-600 transition-colors duration-200 text-sm font-medium"
                >
                  Buy Now
                </a>
              </div>
            </div>
          `).join('');
    }

    function renderMedia() {
      const filter = document.getElementById('filter').value;
      const mediaList = document.getElementById('media-list');
      const affiliateList = document.getElementById('affiliate-list');

      // Filter media based on the selected filter
      const filteredMedia = media.filter(item => {
        if (filter === 'All') return true;
        if (filter === 'Books') return item.type === 'Book';
        if (filter === 'Audiobooks') return item.type === 'Audiobook';
        if (filter === 'TV Shows') return item.type === 'TV Show';
        if (filter === 'Movies') return item.type === 'Movie';
        if (filter === 'Games') return item.type === 'Game';
        return item.status === filter;
      });

      const typeIcons = {
        Book: 'fa-book',
        Audiobook: 'fa-headphones',
        'TV Show': 'fa-tv',
        Movie: 'fa-film',
        Game: 'fa-gamepad'
      };

      // Group filtered media by type
      const groupedMedia = {};
      filteredMedia.forEach(item => {
        if (!groupedMedia[item.type]) {
          groupedMedia[item.type] = [];
        }
        groupedMedia[item.type].push(item);
      });

      // Render grouped media
      let html = '';
      const mediaTypes = ['Book', 'Audiobook', 'TV Show', 'Movie', 'Game'];
      mediaTypes.forEach(type => {
        if (groupedMedia[type] && groupedMedia[type].length > 0) {
          html += `
            <div class="mb-4">
              <h3 class="text-xl font-semibold text-gray-800 mb-2">${type}s</h3>
              <div class="space-y-4">
                ${groupedMedia[type].map(item => `
                  <div class="flex justify-between items-center p-4 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors duration-200">
                    <div class="flex items-center gap-4">
                      <i class="fas ${typeIcons[item.type]} text-blue-500 text-xl"></i>
                      <div>
                        <h4 class="font-medium text-gray-900 text-lg">${sanitizeInput(item.title)}</h4>
                        <p class="text-sm text-gray-600">${item.status}</p>
                      </div>
                    </div>
                    <div class="flex gap-4">
                      <button
                        onclick="toggleStatus(${item.id})"
                        class="text-blue-500 hover:text-blue-600 transition-colors duration-200 text-sm font-medium"
                        aria-label="Toggle status for ${sanitizeInput(item.title)}"
                      >
                        Next Status
                      </button>
                      <button
                        onclick="deleteMedia(${item.id})"
                        class="text-red-500 hover:text-red-600 transition-colors duration-200"
                        aria-label="Delete ${sanitizeInput(item.title)}"
                      >
                        <i class="fas fa-trash"></i>
                      </button>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
        }
      });

      mediaList.innerHTML = html || '<p class="text-gray-500 text-center py-4">Your media list is empty. Add media to start!</p>';

      // Update affiliate links based on filter
      const filterType = filter === 'All' || statusOptions[filter] ? (media[media.length - 1]?.type || 'Book') : filter.replace('s', '');
      const links = affiliateLinks[filterType] || affiliateLinks.Book;
      affiliateList.innerHTML = links.map(link => `
        <a href="${link.url}" target="_blank" rel="noopener noreferrer" class="text-blue-500 hover:underline text-sm">${sanitizeInput(link.text)}</a>
      `).join('');

      fetchSuggestions();
    }

    // Initialize
    updateStatusOptions();
    updateCloudStorageVisibility();
    if (isCloudSyncEnabled && githubPAT) {
      loadFromCloud();
    }
    renderMedia();
    fetchSuggestions();

    // Service Worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js', { scope: '/' }).catch(error => {
          console.error('Service Worker registration failed:', error);
        });
      });
    }

    // Tailwind Config
    tailwind.config = {
      theme: {
        extend: {
          animation: {
            'fade-in': 'fadeIn 0.5s ease-out',
            'fade-in-delayed': 'fadeIn 0.5s ease-out 0.2s'
          },
          keyframes: {
            fadeIn: {
              '0%': { opacity: '0', transform: 'translateY(10px)' },
              '100%': { opacity: '1', transform: 'translateY(0)' }
            }
          }
        }
      }
    };
  </script>
</body>
</html>
